---
description: 
globs: 
alwaysApply: false
---
# TypeScript Coding Standards

## Type Safety

- Avoid using `any` type whenever possible
- Use proper TypeScript types and interfaces
- Only use `any` when absolutely necessary, and document the reason with a comment
- Use generic types instead of `any` when dealing with collections or functions that work with various types
- Always define return types for functions, especially for exported functions
- Use union types instead of overloading when possible

```typescript
// ❌ Avoid
function getData(id: any): any {
  // implementation
}

// ✅ Preferred
function getData<T>(id: string | number): Promise<T> {
  // implementation
}
```

## Interfaces vs Types

- Use `interface` for defining object shapes that may be extended
- Use `type` for unions, intersections, or when you need to use mapped types
- Prefer `interface` for public API definitions
- Extend interfaces instead of using intersection types when possible

```typescript
// ✅ Good practice
interface User {
  id: string;
  name: string;
  email: string;
}

interface AdminUser extends User {
  permissions: string[];
}
```

## Nullability

- Use `undefined` instead of `null` when possible
- Use non-nullable types by default
- Be explicit when a parameter can be undefined using union types

```typescript
// ❌ Avoid
function getUserName(user: User | null): string | null {
  return user ? user.name : null;
}

// ✅ Preferred
function getUserName(user?: User): string | undefined {
  return user?.name;
}
```

## Type Assertions

- Avoid type assertions (`as` syntax) when possible
- Use type guards instead of type assertions
- If you must use type assertions, add a comment explaining why

```typescript
// ❌ Avoid
const user = data as User;

// ✅ Preferred
if (isUser(data)) {
  const user = data; // data is now typed as User
}

// Type guard
function isUser(value: any): value is User {
  return value 
    && typeof value === 'object'
    && 'id' in value
    && 'name' in value;
}
```
